package eigen.types.generated;

// std_msgs equivalents in LCM
// NOTE on unsigned: LCM has no unsigned types except `byte` (uint8).
// For UInt16/32/64 messages below, fields are signed but expected to be non-negative
// and within the original bit-width range in user code.

// ========== Time / Duration / Header ==========
struct time_t {
    // ROS: builtin_interfaces/Time (sec:int32, nanosec:uint32)
    // Here we use int64 for both for safety.
    int64_t sec;
    int64_t nanosec;
}

struct duration_t {
    // ROS: builtin_interfaces/Duration (sec:int32, nanosec:int32/uint32)
    int64_t sec;
    int64_t nanosec;
}

struct header_t {
    time_t stamp;
    string frame_id;
}

// ========== Empty ==========
struct empty_t {
    // ROS: std_msgs/Empty — intentionally no fields
}

// ========== Primitives ==========
struct bool_t {
    // ROS: std_msgs/Bool
    // LCM boolean is supported as `boolean`
    boolean data;
}

struct byte_t {
    // ROS: std_msgs/Byte (uint8)
    byte data;   // 8-bit unsigned
}

struct char_t {
    // ROS: std_msgs/Char (int8)
    int8_t data;
}

struct int8_t_msg {
    // ROS: std_msgs/Int8
    int8_t data;
}

struct uint8_t_msg {
    // ROS: std_msgs/UInt8 — unsigned 8-bit
    byte data;   // use `byte` to stay unsigned
}

struct int16_t_msg {
    // ROS: std_msgs/Int16
    int16_t data;
}

struct uint16_t_msg {
    // ROS: std_msgs/UInt16 — emulate with signed 16-bit; keep values in [0, 65535]
    int16_t data;
}

struct int32_t_msg {
    // ROS: std_msgs/Int32
    int32_t data;
}

struct uint32_t_msg {
    // ROS: std_msgs/UInt32 — emulate with signed 32-bit; keep values in [0, 4294967295]
    int32_t data;
}

struct int64_t_msg {
    // ROS: std_msgs/Int64
    int64_t data;
}

struct uint64_t_msg {
    // ROS: std_msgs/UInt64 — emulate with signed 64-bit; keep values in [0, 2^64-1]
    int64_t data;
}

struct float32_t_msg {
    // ROS: std_msgs/Float32
    float data;
}

struct float64_t_msg {
    // ROS: std_msgs/Float64
    double data;
}

struct string_t {
    // ROS: std_msgs/String
    string data;
}

// ========== Color ==========
struct color_rgba_t {
    // ROS: std_msgs/ColorRGBA
    float r;
    float g;
    float b;
    float a;
}

// ========== MultiArray family ==========
struct multi_array_dimension_t {
    // ROS: std_msgs/MultiArrayDimension
    string label;
    int32_t size;    // number of elements in this dimension
    int32_t stride;  // product of sizes of all lower dimensions
}

struct multi_array_layout_t {
    // ROS: std_msgs/MultiArrayLayout
    int64_t dim_len;                 // number of dimensions
    multi_array_dimension_t dim[dim_len];
    int32_t data_offset;             // padding at front of data
}

// Int8MultiArray
struct int8_multi_array_t {
    multi_array_layout_t layout;
    int64_t data_len;
    int8_t data[data_len];
}

// UInt8MultiArray
struct uint8_multi_array_t {
    multi_array_layout_t layout;
    int64_t data_len;
    byte data[data_len];  // unsigned 8-bit
}

// Int16MultiArray
struct int16_multi_array_t {
    multi_array_layout_t layout;
    int64_t data_len;
    int16_t data[data_len];
}

// UInt16MultiArray (see note on unsigned)
struct uint16_multi_array_t {
    multi_array_layout_t layout;
    int64_t data_len;
    int16_t data[data_len]; // store non-negative values only
}

// Int32MultiArray
struct int32_multi_array_t {
    multi_array_layout_t layout;
    int64_t data_len;
    int32_t data[data_len];
}

// UInt32MultiArray (see note on unsigned)
struct uint32_multi_array_t {
    multi_array_layout_t layout;
    int64_t data_len;
    int32_t data[data_len]; // store non-negative values only
}

// Int64MultiArray
struct int64_multi_array_t {
    multi_array_layout_t layout;
    int64_t data_len;
    int64_t data[data_len];
}

// UInt64MultiArray (see note on unsigned)
struct uint64_multi_array_t {
    multi_array_layout_t layout;
    int64_t data_len;
    int64_t data[data_len]; // store non-negative values only
}

// Float32MultiArray
struct float32_multi_array_t {
    multi_array_layout_t layout;
    int64_t data_len;
    float data[data_len];
}

// Float64MultiArray
struct float64_multi_array_t {
    multi_array_layout_t layout;
    int64_t data_len;
    double data[data_len];
}
